并发日志这一块网上的资料比较少，找了半天，大多数都是讲下syslog函数怎么用，然后就没了，后来看了陈硕的《高性能服务器端编程》，很有收获。    
以下内容主要摘自陈硕的《高性能服务器端编程》  

# 1.日志记录的内容
对于关键进程，日志通常要记录  
1.收到的每条内部消息的id  
2.收到的每条外部消息的全文  
3.发出的每条消息的全文，每条消息都有全局唯一的id  
4.关键内部状态的变更等等  

使用stream风格比较好，首先不用像printf那样保持参数格式的一致，同时是类型安全的，其次当输出的日志级别高于语句的日志级别时，打印日志是一个空操作，开销基本为0  
日志消息需要有多种级别，如DEBUG、INFO、ERROR等  

需要注意往网络写日志是不可靠的！！

日志的滚动功能是必须的，可以设置为每满一个大小就换下一个文件，每过一段时间就换下一个文件  

# 2.日志的结构
一个日志库大体可以分为前端和后端，前端是供来调用的接口api，并生成日志消息，后端负责把前端接受的消息写到目的地    
这是一个典型的多生产者-单消费者问题，对于生产者而言，需要尽量做到低延迟，低cpu开销，无阻塞，对消费者而言，需要做到足够大的吞吐量，并占用较少资源    

# 3.日志的注意点

有个常见问题即万一程序崩溃，那么可能最后若干日志就丢失了，因为日志库不能每条消息都flush，也不能每条日志都open、close文件，这样性能开销太大
muduo使用两种方法解决此问题：  
1.定期刷新缓冲区内的日志消息到硬盘  
2.每条内存中的日志消息都带有cookie，其值为某个函数的地址，这样通过在core dump文件中查找cookie就能找到尚未来得及写入磁盘的消息  

# 4.多线程异步日志的实现
多线程程序对于日志库提出了新的需求：线程安全，即多个线程可以并发写日志，两个线程的日志消息不会出现交织。简单的办法是用一个全局mutex保护IO，或者每个线程单独写一个日志文件，但这两种做法的性能堪忧。前者会造成全部线程抢一个锁，后者可能让业务线程阻塞在写磁盘操作上。  
一个多线程程序的每个进程最好只写一个日志文件，这样分析日志更容易，实现方法是使用一个背景线程负责收集日志的消息，并写入日志文件，其他业务线程指往这个“日志线程”发送日志消息，这称为“异步日志”。  
在多线程服务器程序中，异步日志，或者说是非阻塞日志是必须的，因为写操作偶尔会阻塞长达数秒之久，此时会影响业务模块的执行。因此，在正常的事实业务处理流程中应该彻底避免磁盘IO，这在使用one loop per thread 模型的非阻塞服务器端程序中尤其重要，因为线程是复用的，阻塞线程意味着影响多个客户连接。  
参照muduo日志库，采用双缓冲技术，基本思想是将日志分为前端模块和后端模块，前端负责往接受日志信息，后端负责将日志信息写入文件，例如前端往bufferA中写数据，后端将bufferB的数据写到文件，当bufferA满了以后或定时刷新（一般为3S）后，将bufferA的地址给后端，后端直接将其发出，注意不是复制给后端，同理，后端将bufferB的数据发出后，将bufferB的地址给前端。使用批量发送的方法，避免频繁唤醒后端写操作，降低了开销。  

# 5.实现代码  
```c++
#include "Serverlog.h"

Serverlog::Serverlog(int m_log_buffer_number):log_buffer_number(m_log_buffer_number),cur_log_buffer(NULL),back_buffer_read_number(0)
{
	if( pthread_create(&back_log_thread,NULL,back_deal,this) >0 ) //建立后台线程
	{
		err_quit("back_log_thread_create error");
	}

	if( pthread_detach(back_log_thread) >0 )  //分离事件请求处理线程
	{
		err_quit("back_log pthread_create error");
	}

	if( pthread_cond_init(&back_log_cond,NULL) >0) //初始化事件请求处理线程的条件变量
	{
		err_quit("back_log_cond_init error");
	}

	for(int i=0;i<log_buffer_number;++i) //初始化
	{
		log_buffer *temp=new log_buffer;
		temp->log_number=0;
		front_log_buffer_queue.push(temp); //加入前端队列
	}

	char id[5]="abc";
	openlog(id, LOG_PID|LOG_CONS, LOG_USER);
}

Serverlog::~Serverlog()
{
	closelog();
	//释放log_buffer
	//
	//

}

void Serverlog::append_log(std::string str) //接口，用于写入log
{
	printf("接受到log\n");
	front_deal_log(str);
}

void Serverlog::front_deal_log(std::string str)  //前端处理逻辑，参照muduo,前端的开销不高，并且不涉及对于IO操作，不会阻塞，不必额外开一个线程
{
	if(cur_log_buffer)//当前的块还没写完
	{
		printf("case1:当前块还没写完\n");
		//先保存数据
		cur_log_buffer->data.push(str);
		cur_log_buffer->log_number++;

		log_buffer_clock_cur=clock(); //记录时间
		double duration=(double)(log_buffer_clock_cur-log_buffer_clock_start) / CLOCKS_PER_SEC; //求间隔

		if(cur_log_buffer->log_number==log_buffer_size || duration>3)  //如果当前已满或者时间超过3秒就将其推给后端
		{
			printf("log_buffer已满，前端发送给后端\n");
			back_queue_locker.lock();
			back_log_buffer_queue.push(cur_log_buffer);
			back_buffer_read_number++; //计数器加1
			Pthread_cond_signal(&back_log_cond); //发出信号
			back_queue_locker.unlock();
			cur_log_buffer=NULL; //注意不要忘了
		}
	}
	else  //寻找其他可写的块
	{
		front_queue_locker.lock();  //上锁
		if(!front_log_buffer_queue.empty()) //队列中有可供写的块，如果可供读写的块很多，为了减少浪费，释放一部分
		{
			printf("case2:队列中存在可用块\n");
			cur_log_buffer=front_log_buffer_queue.front();
			front_log_buffer_queue.pop();
			cur_log_buffer->log_number=1;
			cur_log_buffer->data.push(str);

			if(front_log_buffer_queue.size()>4)  //可供读写的块很多,释放一部分
			{

			}
			front_queue_locker.unlock(); //开锁
		}
		else //队列中没有可供写的块,申请新的可供读写的块
		{
			printf("case3:队列中不存在可用块，自己申请\n");
			front_queue_locker.unlock(); //开锁
			cur_log_buffer=new log_buffer;
			cur_log_buffer->log_number=1;
			cur_log_buffer->data.push(str);
		}

		log_buffer_clock_start=clock(); //记录时间
	}
}

void *Serverlog::back_deal(void *ptr)
{
	Serverlog *temp=(Serverlog *)ptr;
	temp->back_deal_log();
	return temp;
}

void Serverlog::back_deal_log()  //后端处理逻辑，涉及磁盘的读写，会阻塞，在分线程上运行
{
	while(1)
	{
		printf("日志后端模块等待\n");
		back_queue_locker.lock();
		while(back_buffer_read_number == 0)
			Pthread_cond_wait(&back_log_cond,&back_queue_locker.m_mutex);

		printf("日志后端模块唤醒\n");
		if(back_log_buffer_queue.empty()) //日志丢失
		{
			back_queue_locker.unlock();
			printf("log_buffer miss\n");
			continue;
		}

		while(!back_log_buffer_queue.empty())
		{
			log_buffer *temp=back_log_buffer_queue.front();
			back_log_buffer_queue.pop();
			back_queue_locker.unlock();

			if(!temp)
			{
				printf("无效的log_buffer\n");
				back_queue_locker.lock();
				continue;
			}

			write_log(temp); //写入log_buffer
			back_buffer_read_number--;

			//将temp放入前端队列，供写入
			front_queue_locker.lock();
			front_log_buffer_queue.push(temp);
			front_queue_locker.unlock();

			back_queue_locker.lock();
		}
		back_queue_locker.unlock();
	}
}

void Serverlog::write_log(void *temp)  //写日志
{
	log_buffer *buf=(log_buffer *)temp;
	printf("接受到log_buffer,大小为%d\n",buf->log_number);
	for(int i=0;i<buf->log_number;++i)
	{
		std::string str=buf->data.front();
		buf->data.pop();
		const char *p = str.c_str();
		syslog(LOG_INFO, p);
	}
}
```
