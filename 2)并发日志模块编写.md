并发日志这一块网上的资料比较少，找了半天，大多数都是讲下syslog函数怎么用，然后就没了，后来看了陈硕的《高性能服务器端编程》，很有收获。    
以下内容主要摘自陈硕的《高性能服务器端编程》  

# 1.日志记录的内容
对于关键进程，日志通常要记录  
1.收到的每条内部消息的id  
2.收到的每条外部消息的全文  
3.发出的每条消息的全文，每条消息都有全局唯一的id  
4.关键内部状态的变更等等  

使用stream风格比较好，首先不用像printf那样保持参数格式的一致，同时是类型安全的，其次当输出的日志级别高于语句的日志级别时，打印日志是一个空操作，开销基本为0  
日志消息需要有多种级别，如DEBUG、INFO、ERROR等  

需要注意往网络写日志是不可靠的！！

日志的滚动功能是必须的，可以设置为每满一个大小就换下一个文件，每过一段时间就换下一个文件  

# 2.日志的结构
一个日志库大体可以分为前端和后端，前端是供来调用的接口api，并生成日志消息，后端负责把前端接受的消息写到目的地    
这是一个典型的多生产者-单消费者问题，对于生产者而言，需要尽量做到低延迟，低cpu开销，无阻塞，对消费者而言，需要做到足够大的吞吐量，并占用较少资源    

# 3.日志的注意点

有个常见问题即万一程序崩溃，那么可能最后若干日志就丢失了，因为日志库不能每条消息都flush，也不能每条日志都open、close文件，这样性能开销太大
muduo使用两种方法解决此问题：  
1.定期刷新缓冲区内的日志消息到硬盘  
2.每条内存中的日志消息都带有cookie，其值为某个函数的地址，这样通过在core dump文件中查找cookie就能找到尚未来得及写入磁盘的消息  

# 4.多线程异步日志的实现
多线程程序对于日志库提出了新的需求：线程安全，即多个线程可以并发写日志，两个线程的日志消息不会出现交织。简单的办法是用一个全局mutex保护IO，或者每个线程单独写一个日志文件，但这两种做法的性能堪忧。前者会造成全部线程抢一个锁，后者可能让业务线程阻塞在写磁盘操作上。  
一个多线程程序的每个进程最好只写一个日志文件，这样分析日志更容易，实现方法是使用一个背景线程负责收集日志的消息，并写入日志文件，其他业务线程指往这个“日志线程”发送日志消息，这称为“异步日志”。  
在多线程服务器程序中，异步日志，或者说是非阻塞日志是必须的，因为写操作偶尔会阻塞长达数秒之久，此时会影响业务模块的执行。因此，在正常的事实业务处理流程中应该彻底避免磁盘IO，这在使用one loop per thread 模型的非阻塞服务器端程序中尤其重要，因为线程是复用的，阻塞线程意味着影响多个客户连接。  
参照muduo日志库，采用双缓冲技术，基本思想是将日志分为前端模块和后端模块，前端负责往接受日志信息，后端负责将日志信息写入文件，例如前端往bufferA中写数据，后端将bufferB的数据写到文件，当bufferA满了以后或定时刷新（一般为3S）后，将bufferA的地址给后端，后端直接将其发出，注意不是复制给后端，同理，后端将bufferB的数据发出后，将bufferB的地址给前端。使用批量发送的方法，避免频繁唤醒后端写操作，降低了开销。  
